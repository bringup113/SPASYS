const express = require('express');
const router = express.Router();

// Ëé∑ÂèñÊâÄÊúâÊäÄÂ∏à
router.get('/technicians', async (req, res) => {
  try {
    const result = await global.pool.query(`
      SELECT t.*, 
             COALESCE(
               json_agg(
                 CASE 
                   WHEN ts.service_id IS NOT NULL THEN
                     json_build_object(
                       'serviceId', ts.service_id,
                       'price', ts.price,
                       'commission', ts.commission,
                       'companyCommissionRuleId', ts.company_commission_rule_id,
                       'companyCommissionRuleName', ccr.name,
                       'companyCommissionType', ccr.commission_type,
                       'companyCommissionRate', ccr.commission_rate
                     )
                   ELSE NULL
                 END
               ) FILTER (WHERE ts.service_id IS NOT NULL),
               '[]'::json
             ) as services
      FROM technicians t
      LEFT JOIN technician_services ts ON t.id = ts.technician_id
      LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
      GROUP BY t.id
      ORDER BY t.created_at ASC
    `);
    
    const technicians = result.rows.map(row => ({
      id: row.id,
      employeeId: row.employee_id,
      countryId: row.country_id,
      hireDate: row.hire_date.toISOString().split('T')[0],
      status: row.status,
      services: row.services || []
    }));
    
    res.json(technicians);
  } catch (error) {
    console.error('Ëé∑ÂèñÊäÄÂ∏àÂàóË°®Â§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Ëé∑ÂèñÂçï‰∏™ÊäÄÂ∏à
router.get('/technicians/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await global.pool.query(`
      SELECT t.*, 
             COALESCE(
               json_agg(
                 CASE 
                   WHEN ts.service_id IS NOT NULL THEN
                     json_build_object(
                       'serviceId', ts.service_id,
                       'price', ts.price,
                       'commission', ts.commission,
                       'companyCommissionRuleId', ts.company_commission_rule_id,
                       'companyCommissionRuleName', ccr.name,
                       'companyCommissionType', ccr.commission_type,
                       'companyCommissionRate', ccr.commission_rate
                     )
                   ELSE NULL
                 END
               ) FILTER (WHERE ts.service_id IS NOT NULL),
               '[]'::json
             ) as services
      FROM technicians t
      LEFT JOIN technician_services ts ON t.id = ts.technician_id
      LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
      WHERE t.id = $1
      GROUP BY t.id
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'ÊäÄÂ∏à‰∏çÂ≠òÂú®' });
    }
    
    const technician = result.rows[0];
    res.json({
      id: technician.id,
      employeeId: technician.employee_id,
      countryId: technician.country_id,
      hireDate: technician.hire_date.toISOString().split('T')[0],
      status: technician.status,
      services: technician.services || []
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÊäÄÂ∏àËØ¶ÊÉÖÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// ÂàõÂª∫ÊäÄÂ∏à
router.post('/technicians', async (req, res) => {
  try {
    const { employeeId, countryId, hireDate, companyCommissionRuleId, services = [] } = req.body;
    
    console.log('üîç ÂêéÁ´ØÊî∂Âà∞ÊäÄÂ∏àÂàõÂª∫ËØ∑Ê±Ç:', {
      employeeId,
      countryId,
      hireDate,
      companyCommissionRuleId,
      services,
      servicesLength: services.length
    });
    
    if (!employeeId || !countryId || !hireDate) {
      return res.status(400).json({ error: 'Â∑•Âè∑„ÄÅÂõΩÁ±çÂíåÂÖ•ËÅåÊó∂Èó¥‰∏çËÉΩ‰∏∫Á©∫' });
    }
    
    // Ê£ÄÊü•Â∑•Âè∑ÊòØÂê¶Â∑≤Â≠òÂú®
    const existingResult = await global.pool.query('SELECT id FROM technicians WHERE employee_id = $1', [employeeId]);
    if (existingResult.rows.length > 0) {
      return res.status(400).json({ error: 'Â∑•Âè∑Â∑≤Â≠òÂú®' });
    }
    
    const technicianId = `tech-${Date.now()}`;
    
    // ÂºÄÂßã‰∫ãÂä°
    const client = await global.pool.connect();
    try {
      await client.query('BEGIN');
      
      // ÂàõÂª∫ÊäÄÂ∏à
      const result = await client.query(
        'INSERT INTO technicians (id, employee_id, country_id, hire_date) VALUES ($1, $2, $3, $4) RETURNING *',
        [technicianId, employeeId, countryId, hireDate]
      );
      
      const technician = result.rows[0];
      
      // Ê∑ªÂä†ÊúçÂä°È°πÁõÆ
      if (services && services.length > 0) {
        for (const service of services) {
          await client.query(
            'INSERT INTO technician_services (technician_id, service_id, price, commission, company_commission_rule_id) VALUES ($1, $2, $3, $4, $5)',
            [technicianId, service.serviceId, service.price, service.commission, service.companyCommissionRuleId || 'default-rule']
          );
        }
      }
      
      await client.query('COMMIT');
      
      // Ëé∑ÂèñÂÆåÊï¥ÁöÑÊäÄÂ∏àÊï∞ÊçÆÔºàÂåÖÊã¨ÊúçÂä°È°πÁõÆÔºâ
      const fullResult = await global.pool.query(`
        SELECT t.*, 
               COALESCE(
                 json_agg(
                   CASE 
                     WHEN ts.service_id IS NOT NULL THEN
                       json_build_object(
                         'serviceId', ts.service_id,
                         'price', ts.price,
                         'commission', ts.commission,
                         'companyCommissionRuleId', ts.company_commission_rule_id,
                         'companyCommissionRuleName', ccr.name,
                         'companyCommissionType', ccr.commission_type,
                         'companyCommissionRate', ccr.commission_rate
                       )
                     ELSE NULL
                   END
                 ) FILTER (WHERE ts.service_id IS NOT NULL),
                 '[]'::json
               ) as services
        FROM technicians t
        LEFT JOIN technician_services ts ON t.id = ts.technician_id
        LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
        WHERE t.id = $1
        GROUP BY t.id
      `, [technicianId]);
      
      const technicianData = {
        id: fullResult.rows[0].id,
        employeeId: fullResult.rows[0].employee_id,
        countryId: fullResult.rows[0].country_id,
        hireDate: fullResult.rows[0].hire_date.toISOString().split('T')[0],
        status: fullResult.rows[0].status,
        services: fullResult.rows[0].services || []
      };
      
      // ÂπøÊí≠ÊäÄÂ∏àÂàõÂª∫‰∫ã‰ª∂
      global.broadcastDataUpdate('technician-created', technicianData);
      
      res.status(201).json(technicianData);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('ÂàõÂª∫ÊäÄÂ∏àÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞ÊäÄÂ∏à
router.put('/technicians/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { employeeId, countryId, hireDate, companyCommissionRuleId, services = [] } = req.body;
    
    // Ê£ÄÊü•Â∑•Âè∑ÊòØÂê¶Â∑≤Ë¢´ÂÖ∂‰ªñÊäÄÂ∏à‰ΩøÁî®
    if (employeeId) {
      const existingResult = await global.pool.query('SELECT id FROM technicians WHERE employee_id = $1 AND id != $2', [employeeId, id]);
      if (existingResult.rows.length > 0) {
        return res.status(400).json({ error: 'Â∑•Âè∑Â∑≤Ë¢´ÂÖ∂‰ªñÊäÄÂ∏à‰ΩøÁî®' });
      }
    }
    
    // ÂºÄÂßã‰∫ãÂä°
    const client = await global.pool.connect();
    try {
      await client.query('BEGIN');
      
      // Êõ¥Êñ∞ÊäÄÂ∏àÂü∫Êú¨‰ø°ÊÅØ
      const result = await client.query(
        'UPDATE technicians SET employee_id = $1, country_id = $2, hire_date = $3, status = $4 WHERE id = $5 RETURNING *',
        [employeeId, countryId, hireDate, req.body.status || 'available', id]
      );
      
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'ÊäÄÂ∏à‰∏çÂ≠òÂú®' });
      }
      
      // Âà†Èô§Áé∞ÊúâÊúçÂä°È°πÁõÆ
      await client.query('DELETE FROM technician_services WHERE technician_id = $1', [id]);
      
      // Ê∑ªÂä†Êñ∞ÁöÑÊúçÂä°È°πÁõÆ
      if (services && services.length > 0) {
        for (const service of services) {
          await client.query(
            'INSERT INTO technician_services (technician_id, service_id, price, commission, company_commission_rule_id) VALUES ($1, $2, $3, $4, $5)',
            [id, service.serviceId, service.price, service.commission, service.companyCommissionRuleId || 'default-rule']
          );
        }
      }
      
      await client.query('COMMIT');
      
      // Ëé∑ÂèñÂÆåÊï¥ÁöÑÊäÄÂ∏àÊï∞ÊçÆÔºàÂåÖÊã¨ÊúçÂä°È°πÁõÆÔºâ
      const fullResult = await global.pool.query(`
        SELECT t.*, 
               COALESCE(
                 json_agg(
                   CASE 
                     WHEN ts.service_id IS NOT NULL THEN
                       json_build_object(
                         'serviceId', ts.service_id,
                         'price', ts.price,
                         'commission', ts.commission,
                         'companyCommissionRuleId', ts.company_commission_rule_id,
                         'companyCommissionRuleName', ccr.name,
                         'companyCommissionType', ccr.commission_type,
                         'companyCommissionRate', ccr.commission_rate
                       )
                     ELSE NULL
                   END
                 ) FILTER (WHERE ts.service_id IS NOT NULL),
                 '[]'::json
               ) as services
        FROM technicians t
        LEFT JOIN technician_services ts ON t.id = ts.technician_id
        LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
        WHERE t.id = $1
        GROUP BY t.id
      `, [id]);
      
      const technicianData = {
        id: fullResult.rows[0].id,
        employeeId: fullResult.rows[0].employee_id,
        countryId: fullResult.rows[0].country_id,
        hireDate: fullResult.rows[0].hire_date.toISOString().split('T')[0],
        status: fullResult.rows[0].status,
        services: fullResult.rows[0].services || []
      };
      
      // ÂπøÊí≠ÊäÄÂ∏àÊõ¥Êñ∞‰∫ã‰ª∂
      global.broadcastDataUpdate('technician-updated', technicianData);
      
      res.json(technicianData);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Êõ¥Êñ∞ÊäÄÂ∏àÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Âà†Èô§ÊäÄÂ∏à
router.delete('/technicians/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    // Ê£ÄÊü•ÊäÄÂ∏àÊòØÂê¶ÊúâËøõË°å‰∏≠ÁöÑËÆ¢Âçï
    const inProgressOrderResult = await global.pool.query(`
      SELECT COUNT(*) as count 
      FROM order_items oi 
      JOIN orders o ON oi.order_id = o.id 
      WHERE oi.technician_id = $1 AND o.status = 'in_progress'
    `, [id]);
    
    if (parseInt(inProgressOrderResult.rows[0].count) > 0) {
      return res.status(400).json({ error: 'ÊäÄÂ∏àËøòÊúâËøõË°å‰∏≠ËÆ¢ÂçïÔºåÊó†Ê≥ïÂà†Èô§' });
    }
    
    const result = await global.pool.query('DELETE FROM technicians WHERE id = $1 RETURNING *', [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'ÊäÄÂ∏à‰∏çÂ≠òÂú®' });
    }
    
    // ÂπøÊí≠ÊäÄÂ∏àÂà†Èô§‰∫ã‰ª∂
    global.broadcastDataUpdate('technician-deleted', { id });
    
    res.json({ message: 'ÊäÄÂ∏àÂà†Èô§ÊàêÂäü' });
  } catch (error) {
    console.error('Âà†Èô§ÊäÄÂ∏àÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞ÊäÄÂ∏àÁä∂ÊÄÅ
router.patch('/technicians/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    if (!['available', 'busy', 'offline'].includes(status)) {
      return res.status(400).json({ error: 'Êó†ÊïàÁöÑÁä∂ÊÄÅÂÄº' });
    }
    
    const result = await global.pool.query(
      'UPDATE technicians SET status = $1 WHERE id = $2 RETURNING *',
      [status, id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'ÊäÄÂ∏à‰∏çÂ≠òÂú®' });
    }
    
    // Ëé∑ÂèñÂÆåÊï¥ÁöÑÊäÄÂ∏àÊï∞ÊçÆÔºàÂåÖÊã¨ÊúçÂä°È°πÁõÆÔºâ
    const fullResult = await global.pool.query(`
      SELECT t.*, 
             COALESCE(
               json_agg(
                 CASE 
                   WHEN ts.service_id IS NOT NULL THEN
                     json_build_object(
                       'serviceId', ts.service_id,
                       'price', ts.price,
                       'commission', ts.commission,
                       'companyCommissionRuleId', ts.company_commission_rule_id,
                       'companyCommissionRuleName', ccr.name,
                       'companyCommissionType', ccr.commission_type,
                       'companyCommissionRate', ccr.commission_rate
                     )
                   ELSE NULL
                 END
               ) FILTER (WHERE ts.service_id IS NOT NULL),
               '[]'::json
             ) as services
      FROM technicians t
      LEFT JOIN technician_services ts ON t.id = ts.technician_id
      LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
      WHERE t.id = $1
      GROUP BY t.id
    `, [id]);
    
    const technicianData = {
      id: fullResult.rows[0].id,
      employeeId: fullResult.rows[0].employee_id,
      countryId: fullResult.rows[0].country_id,
      hireDate: fullResult.rows[0].hire_date.toISOString().split('T')[0],
      status: fullResult.rows[0].status,
      services: fullResult.rows[0].services || []
    };
    
    // ÂπøÊí≠ÊäÄÂ∏àÁä∂ÊÄÅÊõ¥Êñ∞‰∫ã‰ª∂
    global.broadcastDataUpdate('technician-status-updated', technicianData);
    
    res.json(technicianData);
  } catch (error) {
    console.error('Êõ¥Êñ∞ÊäÄÂ∏àÁä∂ÊÄÅÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Ëé∑ÂèñÊäÄÂ∏àÊúçÂä°ÂàÜÈÖç
router.get('/technicians/:id/services', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await global.pool.query(`
      SELECT ts.*, si.name as service_name, ccr.name as company_commission_rule_name, ccr.commission_type, ccr.commission_rate
      FROM technician_services ts
      LEFT JOIN service_items si ON ts.service_id = si.id
      LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
      WHERE ts.technician_id = $1
      ORDER BY ts.created_at ASC
    `, [id]);
    
    const services = result.rows.map(row => ({
      serviceId: row.service_id,
      serviceName: row.service_name,
      price: parseFloat(row.price),
      commission: parseFloat(row.commission),
      companyCommissionRuleId: row.company_commission_rule_id,
      companyCommissionRuleName: row.company_commission_rule_name,
      companyCommissionType: row.commission_type,
      companyCommissionRate: parseFloat(row.commission_rate)
    }));
    
    res.json(services);
  } catch (error) {
    console.error('Ëé∑ÂèñÊäÄÂ∏àÊúçÂä°ÂàÜÈÖçÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

// Êõ¥Êñ∞ÊäÄÂ∏àÊúçÂä°ÂàÜÈÖç
router.put('/technicians/:id/services', async (req, res) => {
  try {
    const { id } = req.params;
    const { services } = req.body;
    
    if (!Array.isArray(services)) {
      return res.status(400).json({ error: 'ÊúçÂä°ÂàÜÈÖçÂøÖÈ°ªÊòØÊï∞ÁªÑ' });
    }
    
    // ÂºÄÂßã‰∫ãÂä°
    const client = await global.pool.connect();
    try {
      await client.query('BEGIN');
      
      // Âà†Èô§Áé∞ÊúâÊúçÂä°ÂàÜÈÖç
      await client.query('DELETE FROM technician_services WHERE technician_id = $1', [id]);
      
      // Ê∑ªÂä†Êñ∞ÁöÑÊúçÂä°ÂàÜÈÖç
      for (const service of services) {
        await client.query(`
          INSERT INTO technician_services (technician_id, service_id, price, commission, company_commission_rule_id)
          VALUES ($1, $2, $3, $4, $5)
        `, [id, service.serviceId, service.price, service.commission, service.companyCommissionRuleId || 'default-rule']);
      }
      
      await client.query('COMMIT');
      
      // ËøîÂõûÊõ¥Êñ∞ÂêéÁöÑÊúçÂä°ÂàÜÈÖç
      const result = await global.pool.query(`
        SELECT ts.*, si.name as service_name, ccr.name as company_commission_rule_name, ccr.commission_type, ccr.commission_rate
        FROM technician_services ts
        LEFT JOIN service_items si ON ts.service_id = si.id
        LEFT JOIN company_commission_rules ccr ON ts.company_commission_rule_id = ccr.id
        WHERE ts.technician_id = $1
        ORDER BY ts.created_at ASC
      `, [id]);
      
      const updatedServices = result.rows.map(row => ({
        serviceId: row.service_id,
        serviceName: row.service_name,
        price: parseFloat(row.price),
        commission: parseFloat(row.commission),
        companyCommissionRuleId: row.company_commission_rule_id,
        companyCommissionRuleName: row.company_commission_rule_name,
        companyCommissionType: row.commission_type,
        companyCommissionRate: parseFloat(row.commission_rate)
      }));
      
      res.json(updatedServices);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Êõ¥Êñ∞ÊäÄÂ∏àÊúçÂä°ÂàÜÈÖçÂ§±Ë¥•:', error);
    res.status(500).json({ error: error.message });
  }
});

module.exports = router; 
